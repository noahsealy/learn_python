None is a singleton, and any variable that stores None is really just a pointer/reference to None
    Its type is NoneType

Is is sometimes better than == when comparing two instances, especially when checking for None.
    This is because is checks not just equality, but also for identity.
    Is will return false if the types are not the same, even if their values are.
    == will return true if the types are not the same, but the values are.

Similar to None, Python has a cache of small integer values.
So, similar to None, a variable set to, say, integer 100 is just a reference to a precached integer object.
Therefore, if you do something like a, b = 100, 100, a is b will return true, as they are both pointing to that same object.
    Everytime you fetch integer = 100, it is the same object you are fetching
    This is true in CPython for -5 to 256.
But c, d = 1000, 1000 will yield c is d as false, as those are not precached integers.
(is operator assesses not just object equality, but also object identity.)

Bytecode can also do math while compiling, in order to simplify functions.
    Example, multiplying two constant integers together.
    B/c of this, sometimes it is WAY faster to return a calculated value, rather than storing it into a variable.
    This is called Constant Folding.